import React, { useState, useEffect } from 'react';
import { Calendar, Lock, Eye, Save, Download, Upload } from 'lucide-react';

const ScheduleManager = () => {
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [isAdmin, setIsAdmin] = useState(false);
  const [passcode, setPasscode] = useState('');
  const [currentMonth, setCurrentMonth] = useState(new Date().getMonth());
  const [currentYear, setCurrentYear] = useState(new Date().getFullYear());
  const [scheduleData, setScheduleData] = useState({});
  const [selectedColor, setSelectedColor] = useState('blue-light');
  const [selectedCell, setSelectedCell] = useState(null);
  const [editText, setEditText] = useState('');
  const [isDragging, setIsDragging] = useState(false);
  const [dragStart, setDragStart] = useState(null);
  const [dragEnd, setDragEnd] = useState(null);
  const [selectedCells, setSelectedCells] = useState([]);

  // 本日の日付
  const today = new Date();
  const isCurrentMonth = currentYear === today.getFullYear() && currentMonth === today.getMonth();
  
  // 本日に戻る
  const goToToday = () => {
    setCurrentYear(today.getFullYear());
    setCurrentMonth(today.getMonth());
  };

  // 24色パレット（8色×濃中淡）
  const colors = {
    'red-dark': '#991B1B', 'red-medium': '#DC2626', 'red-light': '#FCA5A5',
    'orange-dark': '#9A3412', 'orange-medium': '#EA580C', 'orange-light': '#FDBA74',
    'yellow-dark': '#854D0E', 'yellow-medium': '#CA8A04', 'yellow-light': '#FDE047',
    'green-dark': '#166534', 'green-medium': '#16A34A', 'green-light': '#86EFAC',
    'blue-dark': '#1E3A8A', 'blue-medium': '#2563EB', 'blue-light': '#93C5FD',
    'purple-dark': '#6B21A8', 'purple-medium': '#9333EA', 'purple-light': '#D8B4FE',
    'pink-dark': '#9F1239', 'pink-medium': '#E11D48', 'pink-light': '#FBCFE8',
    'gray-dark': '#374151', 'gray-medium': '#6B7280', 'gray-light': '#D1D5DB'
  };

  // 時間列（30分単位、48列）4:00～27:30（翌日3:30）
  const timeSlots = Array.from({ length: 48 }, (_, i) => {
    const totalHalfHours = i + 8; // 4:00から開始（8半時間後）
    const hour = Math.floor(totalHalfHours / 2);
    const minute = totalHalfHours % 2 === 0 ? '00' : '30';
    return `${hour.toString().padStart(2, '0')}:${minute}`;
  });

  // 時間ヘッダー表示用（1時間ごと）
  const timeHeaders = Array.from({ length: 24 }, (_, i) => {
    const hour = i + 4; // 4時から開始
    return hour;
  });

  // 日付行（その月の実際の日数）
  const getDaysInMonth = (year, month) => {
    return new Date(year, month + 1, 0).getDate();
  };
  
  const daysInCurrentMonth = getDaysInMonth(currentYear, currentMonth);
  const days = Array.from({ length: daysInCurrentMonth }, (_, i) => i + 1);

  // 認証処理
  const handleLogin = () => {
    if (passcode === 'admin123') {
      setIsAuthenticated(true);
      setIsAdmin(true);
    } else if (passcode === 'view123') {
      setIsAuthenticated(true);
      setIsAdmin(false);
    } else {
      alert('パスコードが正しくありません');
    }
  };

  // セルクリック処理
  const handleCellClick = (day, time) => {
    if (!isAdmin) return;
    const key = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${time}`;
    setSelectedCells([key]);
    setEditText(scheduleData[key]?.text || '');
  };

  // ドラッグ開始
  const handleMouseDown = (day, time) => {
    if (!isAdmin) return;
    setIsDragging(true);
    setDragStart({ day, time });
    setDragEnd({ day, time });
  };

  // ドラッグ中
  const handleMouseEnter = (day, time) => {
    if (!isAdmin || !isDragging) return;
    // 同じ日付の範囲内のみドラッグ可能
    if (day === dragStart.day) {
      setDragEnd({ day, time });
    }
  };

  // ドラッグ終了
  const handleMouseUp = () => {
    if (!isAdmin || !isDragging) return;
    setIsDragging(false);
    
    if (dragStart && dragEnd) {
      const startIdx = timeSlots.indexOf(dragStart.time);
      const endIdx = timeSlots.indexOf(dragEnd.time);
      const minIdx = Math.min(startIdx, endIdx);
      const maxIdx = Math.max(startIdx, endIdx);
      
      const cells = [];
      for (let i = minIdx; i <= maxIdx; i++) {
        const key = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${dragStart.day.toString().padStart(2, '0')}_${timeSlots[i]}`;
        cells.push(key);
      }
      setSelectedCells(cells);
      
      // 既存のテキストがあれば最初のセルのものを使用
      const firstKey = cells[0];
      setEditText(scheduleData[firstKey]?.text || '');
    }
  };

  // セルが選択範囲内かチェック
  const isCellInSelection = (day, time) => {
    if (!isDragging || !dragStart || !dragEnd) return false;
    if (day !== dragStart.day) return false;
    
    const timeIdx = timeSlots.indexOf(time);
    const startIdx = timeSlots.indexOf(dragStart.time);
    const endIdx = timeSlots.indexOf(dragEnd.time);
    const minIdx = Math.min(startIdx, endIdx);
    const maxIdx = Math.max(startIdx, endIdx);
    
    return timeIdx >= minIdx && timeIdx <= maxIdx;
  };

  // セル更新処理
  const updateCell = () => {
    if (selectedCells.length === 0) return;
    const newData = { ...scheduleData };
    
    if (editText.trim() === '') {
      // 空欄なら削除
      selectedCells.forEach(key => {
        delete newData[key];
      });
    } else {
      // 複数セル選択の場合は先頭にのみテキスト、後続は色のみ
      selectedCells.forEach((key, index) => {
        newData[key] = {
          color: selectedColor,
          text: index === 0 ? editText : '', // 先頭のみテキスト
          isGrouped: selectedCells.length > 1, // グループ化フラグ
          groupIndex: index,
          groupLength: selectedCells.length
        };
      });
    }
    
    setScheduleData(newData);
    setSelectedCells([]);
    setEditText('');
  };

  // データ保存
  const saveData = () => {
    const dataStr = JSON.stringify(scheduleData, null, 2);
    const blob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `schedule_${currentYear}_${currentMonth + 1}.json`;
    a.click();
  };

  // データ読込
  const loadData = (e) => {
    const file = e.target.files[0];
    if (file) {
      const reader = new FileReader();
      reader.onload = (event) => {
        try {
          const data = JSON.parse(event.target.result);
          setScheduleData(data);
        } catch (error) {
          alert('ファイルの読み込みに失敗しました');
        }
      };
      reader.readAsText(file);
    }
  };

  // セル背景色取得
  const getCellStyle = (day, time) => {
    const key = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${time}`;
    const cellData = scheduleData[key];
    if (!cellData) return { backgroundColor: 'white', color: 'black' };
    
    const baseStyle = {
      backgroundColor: colors[cellData.color],
      color: (cellData.color.includes('dark') || cellData.color.includes('medium')) ? 'white' : 'black'
    };
    
    // グループ化されている場合、境界線を調整
    if (cellData.isGrouped) {
      return {
        ...baseStyle,
        borderRight: cellData.groupIndex < cellData.groupLength - 1 ? '1px solid rgba(0,0,0,0.1)' : undefined
      };
    }
    
    return baseStyle;
  };

  // セルテキスト取得
  const getCellText = (day, time) => {
    const key = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${time}`;
    const cellData = scheduleData[key];
    // テキストがある場合のみ表示（グループの先頭セルのみ）
    return cellData?.text || '';
  };

  // 右側に他のテキストがあるかチェック
  const hasTextOnRight = (day, time) => {
    const timeIdx = timeSlots.indexOf(time);
    // 右側のセルをチェック
    for (let i = timeIdx + 1; i < timeSlots.length; i++) {
      const nextTime = timeSlots[i];
      const nextKey = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${nextTime}`;
      const nextData = scheduleData[nextKey];
      if (nextData?.text) {
        // 右にテキストがある場合、その距離を返す
        return i - timeIdx;
      }
    }
    return null; // 右側にテキストなし
  };

  // セル全体のツールチップ用テキスト取得
  const getCellTooltip = (day, time) => {
    const key = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${time}`;
    const cellData = scheduleData[key];
    if (!cellData) return '';
    
    // グループ化されている場合、先頭セルのテキストを探す
    if (cellData.isGrouped && cellData.groupIndex > 0) {
      // 先頭セルのキーを計算
      const timeIdx = timeSlots.indexOf(time);
      const startTimeIdx = timeIdx - cellData.groupIndex;
      if (startTimeIdx >= 0) {
        const startTime = timeSlots[startTimeIdx];
        const startKey = `${currentYear}-${(currentMonth + 1).toString().padStart(2, '0')}-${day.toString().padStart(2, '0')}_${startTime}`;
        return scheduleData[startKey]?.text || '';
      }
    }
    
    return cellData.text || '';
  };

  if (!isAuthenticated) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-blue-50 to-indigo-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-lg shadow-xl p-8 w-full max-w-md">
          <div className="flex items-center justify-center mb-6">
            <Lock className="w-12 h-12 text-indigo-600" />
          </div>
          <h1 className="text-2xl font-bold text-center mb-6 text-gray-800">予定管理システム</h1>
          <div className="space-y-4">
            <input
              type="password"
              placeholder="パスコードを入力"
              value={passcode}
              onChange={(e) => setPasscode(e.target.value)}
              onKeyPress={(e) => e.key === 'Enter' && handleLogin()}
              className="w-full px-4 py-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-transparent"
            />
            <button
              onClick={handleLogin}
              className="w-full bg-indigo-600 text-white py-3 rounded-lg hover:bg-indigo-700 transition"
            >
              ログイン
            </button>
            <div className="text-sm text-gray-600 mt-4 p-3 bg-gray-50 rounded">
              <p className="font-semibold mb-1">デモ用パスコード:</p>
              <p>管理者: <code className="bg-white px-2 py-1 rounded">admin123</code></p>
              <p>閲覧者: <code className="bg-white px-2 py-1 rounded">view123</code></p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 p-4">
      <div className="max-w-full mx-auto">
        {/* ヘッダー */}
        <div className="bg-white rounded-lg shadow p-4 mb-4">
          <div className="flex items-center justify-between flex-wrap gap-4">
            <div className="flex items-center gap-4">
              <Calendar className="w-6 h-6 text-indigo-600" />
              <h1 className="text-xl font-bold text-gray-800">
                {currentYear}年 {currentMonth + 1}月
              </h1>
              {isAdmin ? (
                <span className="bg-green-100 text-green-800 px-3 py-1 rounded-full text-sm">管理者モード</span>
              ) : (
                <span className="bg-blue-100 text-blue-800 px-3 py-1 rounded-full text-sm flex items-center gap-1">
                  <Eye className="w-4 h-4" />閲覧モード
                </span>
              )}
            </div>
            <div className="flex gap-2">
              <button
                onClick={() => {
                  if (currentMonth === 0) {
                    setCurrentMonth(11);
                    setCurrentYear(currentYear - 1);
                  } else {
                    setCurrentMonth(currentMonth - 1);
                  }
                }}
                className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
              >
                前月
              </button>
              <button
                onClick={() => {
                  if (currentMonth === 11) {
                    setCurrentMonth(0);
                    setCurrentYear(currentYear + 1);
                  } else {
                    setCurrentMonth(currentMonth + 1);
                  }
                }}
                className="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300"
              >
                次月
              </button>
              {!isCurrentMonth && (
                <button
                  onClick={goToToday}
                  className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                >
                  本日に戻る
                </button>
              )}
              {isAdmin && (
                <>
                  <button onClick={saveData} className="px-4 py-2 bg-indigo-600 text-white rounded hover:bg-indigo-700 flex items-center gap-2">
                    <Download className="w-4 h-4" />保存
                  </button>
                  <label className="px-4 py-2 bg-green-600 text-white rounded hover:bg-green-700 flex items-center gap-2 cursor-pointer">
                    <Upload className="w-4 h-4" />読込
                    <input type="file" accept=".json" onChange={loadData} className="hidden" />
                  </label>
                </>
              )}
            </div>
          </div>
        </div>

        {/* カラーパレット（管理者のみ） */}
        {isAdmin && (
          <div className="bg-white rounded-lg shadow p-4 mb-4">
            <h3 className="text-sm font-semibold mb-2">カラーパレット</h3>
            <div className="flex flex-wrap gap-2">
              {Object.entries(colors).map(([name, color]) => (
                <button
                  key={name}
                  onClick={() => setSelectedColor(name)}
                  className={`w-10 h-10 rounded border-2 ${selectedColor === name ? 'border-black' : 'border-gray-300'}`}
                  style={{ backgroundColor: color }}
                  title={name}
                />
              ))}
            </div>
          </div>
        )}

        {/* 予定表 */}
        <div className="bg-white rounded-lg shadow overflow-auto">
          <table className="border-collapse w-full text-xs">
            <thead>
              <tr>
                <th className="border border-gray-300 bg-gray-100 p-1 sticky left-0 z-10 w-8">日</th>
                {timeHeaders.map((hour, i) => (
                  <th key={i} colSpan="2" className="border border-gray-300 bg-gray-100 p-1 w-16">{hour}</th>
                ))}
              </tr>
            </thead>
            <tbody>
              {days.map((day) => {
                const isToday = isCurrentMonth && day === today.getDate();
                return (
                  <tr key={day}>
                    <td 
                      className={`border border-gray-300 font-bold text-center p-1 sticky left-0 z-10 w-8 ${
                        isToday ? 'bg-black text-white' : 'bg-gray-100'
                      }`}
                    >
                      {day}
                    </td>
                  {timeSlots.map((time, i) => {
                    const isSelected = isCellInSelection(day, time);
                    const cellText = getCellText(day, time);
                    const tooltip = getCellTooltip(day, time);
                    const distanceToNext = hasTextOnRight(day, time);
                    
                    // テキストがある場合の表示スタイル
                    const hasText = cellText.length > 0;
                    const maxWidth = distanceToNext ? `${distanceToNext * 2}rem` : 'none';
                    
                    return (
                      <td
                        key={i}
                        className={`border border-gray-300 p-0.5 cursor-pointer hover:opacity-80 w-8 h-6 relative ${isSelected ? 'ring-2 ring-indigo-600 z-20' : ''}`}
                        style={{
                          ...getCellStyle(day, time),
                          backgroundColor: isSelected ? 'rgba(99, 102, 241, 0.3)' : getCellStyle(day, time).backgroundColor
                        }}
                        onMouseDown={() => handleMouseDown(day, time)}
                        onMouseEnter={() => handleMouseEnter(day, time)}
                        onMouseUp={handleMouseUp}
                        title={tooltip}
                      >
                        {hasText && (
                          <div 
                            className="absolute left-0.5 top-0.5 text-[10px] font-semibold leading-tight whitespace-nowrap z-10"
                            style={{ 
                              maxWidth: maxWidth,
                              overflow: 'hidden',
                              textOverflow: distanceToNext ? 'ellipsis' : 'clip'
                            }}
                          >
                            {cellText}
                          </div>
                        )}
                      </td>
                    );
                  })}
                </tr>
              );
              })}
            </tbody>
          </table>
        </div>

        {/* 編集モーダル */}
        {selectedCells.length > 0 && isAdmin && (
          <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
            <div className="bg-white rounded-lg p-6 w-96">
              <h3 className="text-lg font-bold mb-2">予定を編集</h3>
              <p className="text-sm text-gray-600 mb-4">
                {selectedCells.length}個のセルを選択中
                {selectedCells.length > 1 && ` (${selectedCells.length * 0.5}時間)`}
              </p>
              <input
                type="text"
                value={editText}
                onChange={(e) => setEditText(e.target.value)}
                placeholder="予定を入力（空欄で削除）"
                className="w-full px-3 py-2 border rounded mb-4"
                autoFocus
                onKeyPress={(e) => e.key === 'Enter' && updateCell()}
              />
              <div className="flex gap-2">
                <button
                  onClick={updateCell}
                  className="flex-1 bg-indigo-600 text-white py-2 rounded hover:bg-indigo-700"
                >
                  保存
                </button>
                <button
                  onClick={() => {
                    setSelectedCells([]);
                    setEditText('');
                  }}
                  className="flex-1 bg-gray-300 py-2 rounded hover:bg-gray-400"
                >
                  キャンセル
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default ScheduleManager;